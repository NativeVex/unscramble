'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.disconnect = _disconnect;
exports.listTables = _listTables;
exports.executeQuery = _executeQuery;
exports.listDatabases = _listDatabases;
exports.getQuerySelectTop = _getQuerySelectTop;
exports.wrapQuery = wrapQuery;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _pg = require('pg');

var _tunnel = require('../tunnel');

var _tunnel2 = _interopRequireDefault(_tunnel);

var debug = require('../../debug')('db:clients:postgresql');

exports['default'] = function (serverInfo, databaseName) {
  var _this = this;

  return new Promise(function callee$1$0(resolve, reject) {
    var connecting, tunnel, localPort, client;
    return regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          connecting = true;
          tunnel = null;

          if (!serverInfo.ssh) {
            context$2$0.next = 14;
            break;
          }

          debug('creating ssh tunnel');
          context$2$0.prev = 4;
          context$2$0.next = 7;
          return regeneratorRuntime.awrap((0, _tunnel2['default'])(serverInfo));

        case 7:
          tunnel = context$2$0.sent;
          context$2$0.next = 14;
          break;

        case 10:
          context$2$0.prev = 10;
          context$2$0.t0 = context$2$0['catch'](4);

          connecting = false;
          return context$2$0.abrupt('return', reject(context$2$0.t0));

        case 14:

          debug('creating database connection');
          localPort = tunnel ? tunnel.address().port : 0;
          client = new _pg.Client(_configDatabase(serverInfo, databaseName, localPort));

          if (tunnel) {
            tunnel.on('error', function (error) {
              if (connecting) {
                connecting = false;
                return reject(error);
              }
            });
          }

          client.connect(function (err) {
            connecting = false;
            if (err) {
              client.end();
              return reject(err);
            }

            debug('connected');
            resolve({
              wrapQuery: wrapQuery,
              disconnect: function disconnect() {
                return _disconnect(client);
              },
              listTables: function listTables() {
                return _listTables(client);
              },
              executeQuery: function executeQuery(query) {
                return _executeQuery(client, query);
              },
              listDatabases: function listDatabases() {
                return _listDatabases(client);
              },
              getQuerySelectTop: function getQuerySelectTop(table, limit) {
                return _getQuerySelectTop(client, table, limit);
              }
            });
          });

        case 19:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this, [[4, 10]]);
  });
};

function _disconnect(client) {
  client.end();
}

function _listTables(client) {
  return new Promise(function (resolve, reject) {
    var sql = 'select table_name from information_schema.tables where table_schema = $1 order by table_name';
    var params = ['public'];
    client.query(sql, params, function (err, data) {
      if (err) return reject(err);
      resolve(data.rows.map(function (row) {
        return row.table_name;
      }));
    });
  });
}

function _executeQuery(client, query) {
  return new Promise(function (resolve, reject) {
    client.query(query, function (err, data) {
      if (err) return reject(err);
      resolve({
        rows: data.rows,
        fields: data.fields
      });
    });
  });
}

function _listDatabases(client) {
  return new Promise(function (resolve, reject) {
    var sql = 'select datname from pg_database where datistemplate = $1 order by datname';
    var params = [false];
    client.query(sql, params, function (err, data) {
      if (err) return reject(err);
      resolve(data.rows.map(function (row) {
        return row.datname;
      }));
    });
  });
}

function _getQuerySelectTop(client, table, limit) {
  return 'select * from ' + wrapQuery(table) + ' limit ' + limit;
}

function wrapQuery(item) {
  return '"' + item + '"';
}

function _configDatabase(serverInfo, databaseName, localPort) {
  var host = localPort ? '127.0.0.1' : serverInfo.host || serverInfo.socketPath;
  var port = localPort || serverInfo.port;

  var config = {
    host: host,
    port: port,
    user: serverInfo.user,
    password: serverInfo.password,
    database: databaseName
  };

  return config;
}