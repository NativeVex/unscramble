'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _net = require('net');

var _net2 = _interopRequireDefault(_net);

var _ssh2 = require('ssh2');

var _utils = require('../utils');

var debug = require('../debug')('db:tunnel');

exports['default'] = function (serverInfo) {
  var _this2 = this;

  return new Promise(function callee$1$0(resolve, reject) {
    var config, connections, server;
    return regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      var _this = this;

      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          debug('configuring tunnel');
          context$2$0.next = 3;
          return regeneratorRuntime.awrap(_configTunnel(serverInfo));

        case 3:
          config = context$2$0.sent;
          connections = [];

          debug('creating ssh tunnel server');
          server = _net2['default'].createServer(function callee$2$0(conn) {
            var client, localPort;
            return regeneratorRuntime.async(function callee$2$0$(context$3$0) {
              while (1) switch (context$3$0.prev = context$3$0.next) {
                case 0:
                  conn.on('error', function (err) {
                    return server.emit('error', err);
                  });

                  debug('creating ssh tunnel client');
                  client = new _ssh2.Client();

                  connections.push(conn);

                  client.on('error', function (err) {
                    return server.emit('error', err);
                  });

                  client.on('ready', function () {
                    debug('connected ssh tunnel client');
                    connections.push(client);

                    debug('forwarding ssh tunnel client output');
                    client.forwardOut(config.srcHost, config.srcPort, config.dstHost, config.dstPort, function (err, sshStream) {
                      if (err) {
                        server.close();
                        server.emit('error', err);
                        return;
                      }
                      sshStream.once('close', function () {
                        debug('closed ssh tunnel stream output');
                        server.close();
                      });
                      conn.pipe(sshStream).pipe(conn);
                    });
                  });

                  context$3$0.prev = 6;
                  context$3$0.next = 9;
                  return regeneratorRuntime.awrap((0, _utils.getPort)());

                case 9:
                  localPort = context$3$0.sent;

                  debug('connecting ssh tunnel client');
                  client.connect(_extends({}, config, { localPort: localPort }));
                  context$3$0.next = 17;
                  break;

                case 14:
                  context$3$0.prev = 14;
                  context$3$0.t0 = context$3$0['catch'](6);

                  server.emit('error', context$3$0.t0);

                case 17:
                case 'end':
                  return context$3$0.stop();
              }
            }, null, _this, [[6, 14]]);
          });

          server.once('close', function () {
            debug('close ssh tunnel server');
            connections.forEach(function (conn) {
              return conn.end();
            });
          });

          debug('connecting ssh tunnel server');
          server.listen(config.localPort, config.localHost, function (err) {
            if (err) return reject(err);

            debug('connected ssh tunnel server');
            resolve(server);
          });

        case 10:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this2);
  });
};

function _configTunnel(serverInfo) {
  var config;
  return regeneratorRuntime.async(function _configTunnel$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        config = {
          username: serverInfo.ssh.user,
          port: serverInfo.ssh.port,
          host: serverInfo.ssh.host,
          dstPort: serverInfo.port,
          dstHost: serverInfo.host,
          sshPort: 22,
          srcPort: 0,
          srcHost: 'localhost',
          localHost: 'localhost'
        };

        if (serverInfo.ssh.password) config.password = serverInfo.ssh.password;

        if (!serverInfo.ssh.privateKey) {
          context$1$0.next = 6;
          break;
        }

        context$1$0.next = 5;
        return regeneratorRuntime.awrap((0, _utils.readFile)(serverInfo.ssh.privateKey));

      case 5:
        config.privateKey = context$1$0.sent;

      case 6:
        return context$1$0.abrupt('return', config);

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}
module.exports = exports['default'];